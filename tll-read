#!/usr/bin/env python3
# vim: sts=4 sw=4 et

import argparse
import collections
import decimal
import enum
import logging
import signal
import sys
import traceback
import yaml

from tll import logger
from tll.channel import Context
from tll.chrono import TimePoint, Duration
from tll.config import Config, Url
from tll.processor import Loop

parser = argparse.ArgumentParser(description='Read messages from channel')
parser.add_argument('channel', metavar='CHANNEL', type=str,
                    help='source channel')
parser.add_argument('-l', '--loglevel', dest='loglevel', default='warning',
                    help='logging level', choices=['trace', 'debug', 'info', 'warning', 'error', 'critical'])
parser.add_argument('-c', '--config', dest='config',
                    help='load CONFIG for additional parameters, if CHANNEL is empty - take it from config')
parser.add_argument('-S', '--scheme', metavar='SCHEME', type=str,
                    help='scheme file')
parser.add_argument('--no-autoclose', dest='autoclose', action='store_false', default=True,
                    help='do not autoclose channel')

channels = parser.add_argument_group('Channel options')
channels.add_argument('-m', '--module', dest='modules', action='append',
                    default=[],
                    help='additional channel modules')
channels.add_argument('-E', '--extra-channel', dest='extra_channels', action='append', default=[],
                    help='extra channels')
channels.add_argument('-M', '--master', dest='master',
                    help='master channel')

filtering = parser.add_argument_group('Filtering')
filtering.add_argument('-f', '--filter', dest='filter',
                    help='lua filter expression')
filtering.add_argument('-F', '--filter-file', dest='filter_file', metavar='FILE',
                    help='lua file with filter script')
filtering.add_argument('--seq-list', dest='seq_list', type=lambda s: [int(x.strip()) for x in s.split(',')],
                    help='limit output to seq list, conflicts with --message')
filtering.add_argument('--message', dest='messages', action='append',
                    help='filter by message name, conflicts with --seq-list')
filtering.add_argument('--dump-code', dest='dump_code', action='store_true', default=False,
                    help='dump generated lua filter code')

class SeqType(enum.Enum):
    Nothing = 0
    Seq = 1
    Count = 2
    Reverse = 3

Seq = collections.namedtuple('Seq', ['type', 'value'])
Seq.Type = SeqType

def parseone(string):
    if string == '':
        return Seq(Seq.Type.Nothing, 0)
    elif string.startswith('+'):
        return Seq(Seq.Type.Count, int(string[1:]))
    elif string.startswith('-'):
        return Seq(Seq.Type.Reverse, int(string[1:]))
    return Seq(Seq.Type.Seq, int(string))

def parseseq(string):
    r = string.split(':')
    if len(r) == 1:
        return (parseone(r[0]), parseone(''))
    elif len(r) == 2:
        return (parseone(r[0]), parseone(r[1]))
    else:
        raise ValueError("Invalid seq format")

parser.add_argument('-s', '--seq', dest='seq', type=parseseq,
                    default=(parseone(''), parseone('')), metavar='BEGIN[:END]',
                    help='seq limits')

args = parser.parse_args()
if args.seq[1].type == Seq.Type.Reverse:
    raise SystemExit(f"Negative index not supported for second position: --seq XXX:-{args.seq[1].value}")

logger.init()
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s %(levelname)-7s %(name)s: %(message)s')
logger.configure({'levels.*': args.loglevel})

if args.config:
    cfg = yaml.safe_load(open(args.config))
    c = cfg.pop('channel', None)
    if c and not args.channel:
        args.channel = c
    for k,v in cfg.items():
        if not hasattr(args, k):
            continue
        a = getattr(args, k)
        if k in ('modules', 'messages', 'extra_channels'):
            setattr(args, k, list(set(a + v),))
        elif not a:
            setattr(args, k, v)

ctx = Context()
for m in args.modules:
    ctx.load(m, 'channel_module')
loop = Loop(ctx)

def loop_stop(c, m):
    if m.type != m.Type.State:
        return
    if c.State(m.msgid) in (c.State.Closed, c.State.Error):
        loop.stop = 1

extra = []
for url in args.extra_channels:
    c = ctx.Channel(url)
    c.callback_add(loop_stop, mask=c.MsgMask.State)
    loop.add(c)
    extra += [c]

master = None
if args.master:
    master = ctx.Channel(args.master, name='master')
    master.callback_add(loop_stop, mask=master.MsgMask.State)
    loop.add(master)

url = Url.parse(args.channel)
if args.scheme:
    url['scheme'] = args.scheme
if 'name' not in url:
    url['name'] = 'data'
if 'autoclose' not in url and args.autoclose:
    url['autoclose'] = 'yes'

def build_code(args):
    if args.filter_file:
        if args.seq_list or args.messages or args.filter:
            raise SystemExit("Conflicting script file and custom filters")
        return 'file://' + args.filter_file
    if not (args.messages or args.seq_list or args.filter or args.dump_code):
        return None
    code = [f'''function luatll_filter(seq, name, data, msgid, addr, time)''']
    if args.seq_list:
        code += ['    if ' + ' and '.join(f'seq ~= {s}' for s in args.seq_list) + ' then return false end']
    if args.messages:
        code += ['    if ' + ' and '.join(f'name ~= "{n}"' for s in args.messages) + ' then return false end']
    if args.filter:
        code += ['    return ' + args.filter]
    else:
        code += ['    return true']
    code += ['end']
    return '\n'.join(code)

code = build_code(args)
if args.dump_code:
    print(code or '')
    sys.exit(0)

if code is not None:
    if not ctx.has_impl('lua+'):
        ctx.load('tll-lua', 'channel_module')
    url.proto = 'lua+' + url.proto
    url['lua.code'] = code

# TODO: Move to lua
count = -1
skip = 0
if args.seq[0].type == Seq.Type.Count:
    skip = args.seq[0].value
if args.seq[1].type == Seq.Type.Count:
    count = args.seq[1].value

def bytearray_representer(dumper, data):
    if all(x < 0x80 for x in data):
        return dumper.represent_scalar('tag:yaml.org,2002:str', data.decode('ascii'))
    return dumper.represent_binary(data)
yaml.add_representer(bytearray, bytearray_representer)

def decimal_representer(dumper, data):
    return dumper.represent_scalar('tag:yaml.org,2002:str', str(data))
yaml.add_representer(decimal.Decimal, decimal_representer)

def timepoint_representer(dumper, data):
    return dumper.represent_scalar('tag:yaml.org,2002:str', str(data))
yaml.add_representer(TimePoint, timepoint_representer)

def duration_representer(dumper, data):
    return dumper.represent_scalar('tag:yaml.org,2002:str', str(data))
yaml.add_representer(Duration, duration_representer)

def enum_representer(dumper, data):
    return dumper.represent_scalar('tag:yaml.org,2002:str', data.name)
yaml.add_multi_representer(enum.Enum, enum_representer)

# Don't generate aliases
yaml.Dumper.ignore_aliases = lambda *args: True

def format_data(c, msg):
    global skip, count
    if skip != 0:
        skip -= 1
        return
    try:
        s = c.scheme
        #meta = collections.OrderedDict({'seq':msg.seq})
        meta = {'seq':msg.seq}
        if not s:
            meta['msgid'] = msg.msgid
            meta['data'] = msg.data.tobytes()
        else:
            m = s.unpack(msg)
            meta['name'] = m.SCHEME.name
            meta['data'] = m.as_dict()
        print(yaml.dump([meta], sort_keys=False, allow_unicode=True))
    except Exception:
        print("Failed to process message")
        traceback.print_exc()
        loop.stop = 1

    count -= 1
    if count == 0:
        loop.stop = 1


channel = ctx.Channel(url, master=master)
channel.callback_add(loop_stop, mask=channel.MsgMask.State)
loop.add(channel)

for c in extra:
    c.open()

if master:
    master.open()
    while master.state != master.State.Active:
        loop.step(1)

cfg = Config()
if args.seq[0].type == Seq.Type.Seq:
    cfg['seq'] = str(args.seq[0].value)

if args.seq[0].type == Seq.Type.Reverse:
    channel.open()
    while channel.state == channel.State.Opening:
        loop.step(0.001)
    last = channel.config.get('seq', None)
    if not last:
        raise SystemExit("Channel has not 'seq' field in config")
    cfg['seq'] = str(int(last) - args.seq[0].value)
    channel.close()
    loop.stop = 0

channel.callback_add(format_data, mask=channel.MsgMask.Data)
channel.open(cfg)

signal.signal(signal.SIGINT, signal.SIG_DFL)
try:
    loop.run(1)
finally:
    channel.free()
    if master:
        master.free()
    for c in extra:
        c.free()
